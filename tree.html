<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Low Poly Tree on Floating Island (Reader Repositioned, Orb Hover, Orbs Farther)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000; }
        canvas { display: block; }
        .message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 100;
            display: none;
            text-align: center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="messageBox" class="message-box"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let island, tree;
        const islandBaseRadius = 16; 
        let skyBackground; 
        const baseTrunkRadius = 4.2; 
        const overallTrunkHeight = 35; 
        const foliageClumpTopY = (overallTrunkHeight + 4.0) + (10.0 * 0.9);


        let linkOrbs = []; 
        let raycaster, mouse;
        let currentHoveredOrbGroup = null; // For hover effect
        const hoverScaleFactor = 1.2;


        // Vertex Shader for the sky
        const skyVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Fragment Shader for a Night Sky with Twinkling Dot Stars
        const nightSkyFragmentShader = `
            varying vec2 vUv;
            uniform float iTime;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
            }

            float starShape(vec2 coord, float radius, float blur) {
                return 1.0 - smoothstep(radius - blur, radius + blur, length(coord));
            }

            void main() {
                vec3 color = vec3(0.01, 0.015, 0.035); // Slightly lighter dark blue sky

                // Star Layer 1: Smaller, denser stars
                vec2 st1 = vUv * vec2(250.0, 125.0); 
                vec2 ipos1 = floor(st1);
                vec2 fpos1 = fract(st1) - 0.5; 
                float rnd1 = random(ipos1);

                if (rnd1 > 0.985) { 
                    float baseStarSize = (random(ipos1 + 0.1) * 0.03 + 0.015) * ( (1.0-vUv.y) * 0.5 + 0.5);
                    float throbSpeed = random(ipos1 + 0.15) * 1.5 + 0.5;
                    float throbPhase = random(ipos1 + 0.18) * 6.28;
                    float throbAmount = (sin(iTime * throbSpeed + throbPhase) * 0.2 + 0.8); 
                    float starSize = baseStarSize * throbAmount;

                    float starBlur = starSize * 0.5;
                    float starMask = starShape(fpos1, starSize, starBlur);
                    
                    if (starMask > 0.0) {
                        float starIntensity = pow((rnd1 - 0.985) / (1.0 - 0.985), 2.0) * 0.8 + 0.2; 
                        float twinkleSpeed = random(ipos1 + 0.2) * 2.5 + 0.8;
                        float twinklePhase = random(ipos1 + 0.3) * 6.28;
                        float twinkle = (sin(iTime * twinkleSpeed + twinklePhase) * 0.45 + 0.55); 
                        
                        vec3 starBaseColor = vec3(0.85, 0.85, 1.0);
                        vec3 starColorVariation = (vec3(random(ipos1 + 0.4), random(ipos1 + 0.5), random(ipos1 + 0.6)) - 0.5) * 0.3;
                        vec3 finalStarColor = starBaseColor + starColorVariation;
                        
                        color += finalStarColor * starIntensity * twinkle * starMask * 0.8; 
                    }
                }

                // Star Layer 2: Slightly larger, less numerous stars
                vec2 st2 = vUv * vec2(100.0, 50.0); 
                vec2 ipos2 = floor(st2);
                vec2 fpos2 = fract(st2) - 0.5;
                float rnd2 = random(ipos2);

                if (rnd2 > 0.992) { 
                    float baseStarSize = (random(ipos2 + 0.15) * 0.04 + 0.025) * ( (1.0-vUv.y) * 0.4 + 0.6);
                    float throbSpeed = random(ipos2 + 0.17) * 1.2 + 0.4;
                    float throbPhase = random(ipos2 + 0.19) * 6.28;
                    float throbAmount = (sin(iTime * throbSpeed + throbPhase) * 0.25 + 0.75); 
                    float starSize = baseStarSize * throbAmount;
                    
                    float starBlur = starSize * 0.4;
                    float starMask = starShape(fpos2, starSize, starBlur);

                    if (starMask > 0.0) {
                        float starIntensity = pow((rnd2 - 0.992) / (1.0 - 0.992), 1.8) * 0.7 + 0.3;
                        float twinkleSpeed = random(ipos2 + 0.25) * 2.0 + 0.5;
                        float twinklePhase = random(ipos2 + 0.35) * 6.28;
                        float twinkle = (sin(iTime * twinkleSpeed + twinklePhase) * 0.4 + 0.6);
                        
                        vec3 starBaseColor = vec3(1.0, 0.95, 0.9);
                        vec3 starColorVariation = (vec3(random(ipos2 + 0.45), random(ipos2 + 0.55), random(ipos2 + 0.65)) - 0.5) * 0.2;
                        vec3 finalStarColor = starBaseColor + starColorVariation;

                        color += finalStarColor * starIntensity * twinkle * starMask * 1.0;
                    }
                }
                
                color = clamp(color, 0.0, 1.0);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('messageBox');
            if (messageBox) {
                messageBox.textContent = message;
                messageBox.style.display = 'block';
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, duration);
            } else {
                console.log("Message box not found, original message:", message);
            }
        }

        function init() {
            try {
                // Scene
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x00000A, 130, 650); 

                // Starry Night Sky Background
                const skyGeometry = new THREE.SphereGeometry(1200, 64, 32); 
                const skyMaterial = new THREE.ShaderMaterial({
                    vertexShader: skyVertexShader, 
                    fragmentShader: nightSkyFragmentShader, 
                    uniforms: {
                        iTime: { value: 0.0 } 
                    },
                    side: THREE.BackSide, 
                    depthWrite: false 
                });
                skyBackground = new THREE.Mesh(skyGeometry, skyMaterial);
                scene.add(skyBackground);

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2200); 
                camera.position.set(60, 55, 110); 

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 0.75; 
                document.body.appendChild(renderer.domElement);

                // Controls
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.minDistance = 30; 
                controls.maxDistance = 550; 
                controls.maxPolarAngle = Math.PI / 1.7;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x405070, 1.5); 
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xA0B0FF, 1.8); 
                directionalLight.position.set(70, 100, 100); 
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 4096; 
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 1;
                directionalLight.shadow.camera.far = 450; 
                const shadowCamSize = 140; 
                directionalLight.shadow.camera.left = -shadowCamSize;
                directionalLight.shadow.camera.right = shadowCamSize;
                directionalLight.shadow.camera.top = shadowCamSize;
                directionalLight.shadow.camera.bottom = -shadowCamSize;
                directionalLight.shadow.bias = -0.0005; 
                scene.add(directionalLight);
                // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera); 
                // scene.add(shadowHelper);

                // Create elements
                island = createFloatingIsland();
                island.position.y = -22; 
                scene.add(island);

                tree = createOldTree();
                tree.position.y = 12.5; 
                island.add(tree);

                const wiseReader = createWiseReader();
                const readerOverallScale = 0.85; 
                const lowerBodyDepth = 2.2 * readerOverallScale; 
                const readerCenterToBack = lowerBodyDepth / 2 + (0.3 * readerOverallScale); 
                
                // Position reader on the +X, +Z side of the tree, leaning against it, facing outwards.
                // Angle from tree's +X axis towards +Z axis.
                const readerAngle = Math.PI / 4; // 45 degrees
                const readerDistFromTrunk = baseTrunkRadius + readerCenterToBack - 0.7;

                wiseReader.position.set(
                    tree.position.x + Math.cos(readerAngle) * readerDistFromTrunk,
                    13.2, 
                    tree.position.z + Math.sin(readerAngle) * readerDistFromTrunk
                );
                // Reader's local +Z (front) should point along the 'readerAngle' direction.
                wiseReader.rotation.y = readerAngle; 
                island.add(wiseReader);

                // Create and add link orbs
                createLinkOrbs();

                // Raycasting setup
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
                renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);


                window.addEventListener('resize', onWindowResize, false);
                animate();
                showMessage("Reader repositioned. Orbs larger, more scattered, and hoverable.", 6000);

            } catch (error) {
                console.error("Error during initialization:", error);
                showMessage("Error initializing 3D scene. Check console for details.", 5000);
            }
        }

        function createFloatingIsland() {
            const islandGroup = new THREE.Group();
            const earthMaterial = new THREE.MeshStandardMaterial({
                color: 0x6A4030, 
                roughness: 0.9, metalness: 0.02, flatShading: true
            });
            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x407A00, 
                roughness: 0.93, metalness: 0.0, flatShading: true
            });

            const earthHeight = 20; 
            const earthTopRadius = islandBaseRadius * 1.15; 
            const earthBottomRadius = islandBaseRadius * 0.75; 
            const radialSegments = 28; 
            const heightSegments = 10;  

            const baseEarthGeom = new THREE.CylinderGeometry(earthTopRadius, earthBottomRadius, earthHeight, radialSegments, heightSegments);
            const positions = baseEarthGeom.attributes.position;
            const normals = baseEarthGeom.attributes.normal;

            const organicScale = 2.5; 
            const warpFrequency = 0.2; 
            const warpAmplitude = islandBaseRadius * 0.3; 

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                const angle = Math.atan2(z, x);
                const warpFactor = (Math.sin(angle * 3.0 + y * warpFrequency) + Math.cos(angle * 2.0 - y * warpFrequency * 0.7)) * 0.5; 
                const warpOffsetX = Math.cos(angle) * warpAmplitude * warpFactor;
                const warpOffsetZ = Math.sin(angle) * warpAmplitude * warpFactor;
                let currentX = x + warpOffsetX;
                let currentZ = z + warpOffsetZ;
                const horizontalInfluence = Math.sqrt(currentX*currentX + currentZ*currentZ) / (earthTopRadius + warpAmplitude);
                const randomFactor = (Math.random() - 0.5) * organicScale * horizontalInfluence;
                const nx = normals.getX(i); 
                const nz = normals.getZ(i);
                if (y > -earthHeight/2 + 0.1) { 
                    currentX += nx * randomFactor * (1 + Math.abs(y/(earthHeight/2)) * 0.7);
                    currentZ += nz * randomFactor * (1 + Math.abs(y/(earthHeight/2)) * 0.7);
                }
                positions.setX(i, currentX);
                positions.setZ(i, currentZ);
                if (Math.abs(y) < earthHeight/2 - 0.1) { 
                    positions.setY(i, y + (Math.random() - 0.5) * organicScale * 0.4 * horizontalInfluence * (1.0 - Math.abs(y / (earthHeight / 2))));
                }
            }
            baseEarthGeom.computeVertexNormals(); 
            const earthMesh = new THREE.Mesh(baseEarthGeom, earthMaterial);
            earthMesh.castShadow = true; earthMesh.receiveShadow = true;
            islandGroup.add(earthMesh);

            const grassHeight = 4.0; 
            const grassCapGeom = new THREE.CylinderGeometry(earthTopRadius * 1.08, earthTopRadius * 1.04, grassHeight, radialSegments, 2); 
            const grassPositions = grassCapGeom.attributes.position;
             for (let i = 0; i < grassPositions.count; i++) {
                const x = grassPositions.getX(i);
                const y = grassPositions.getY(i);
                const z = grassPositions.getZ(i);
                const angle = Math.atan2(z,x);
                const warpFactor = (Math.sin(angle * 3.0 + y * warpFrequency*0.5) + Math.cos(angle * 2.0 - y * warpFrequency * 0.35)) * 0.5;
                const warpOffsetX = Math.cos(angle) * warpAmplitude * 0.3 * warpFactor; 
                const warpOffsetZ = Math.sin(angle) * warpAmplitude * 0.3 * warpFactor;
                grassPositions.setX(i, x + warpOffsetX + (Math.random() -0.5) * 0.7);
                grassPositions.setZ(i, z + warpOffsetZ + (Math.random() -0.5) * 0.7);
                if(y > grassHeight/2 - 0.1) { 
                    grassPositions.setY(i, y + (Math.random() - 0.5) * 0.6);
                }
            }
            grassCapGeom.computeVertexNormals();
            const grassMesh = new THREE.Mesh(grassCapGeom, grassMaterial);
            grassMesh.position.y = earthHeight / 2 + grassHeight / 2 - 0.8; 
            grassMesh.castShadow = true; grassMesh.receiveShadow = true;
            islandGroup.add(grassMesh);

            const numSmallRocks = 16; 
            for (let i = 0; i < numSmallRocks; i++) {
                const rockSize = Math.random() * 4.5 + 2.0; 
                const rockGeom = new THREE.IcosahedronGeometry(rockSize, Math.floor(Math.random()*2)); 
                const rockMesh = new THREE.Mesh(rockGeom, earthMaterial);
                const angle = Math.random() * Math.PI * 2;
                const radiusFactor = 1.0 + (Math.random() - 0.5) * 0.4; 
                const distance = (earthTopRadius + warpAmplitude) * radiusFactor + Math.random() * 18 + 12; 
                rockMesh.position.set(
                    Math.cos(angle) * distance,
                    Math.random() * 10 - 18, 
                    Math.sin(angle) * distance
                );
                rockMesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rockMesh.castShadow = true; rockMesh.receiveShadow = true;
                islandGroup.add(rockMesh);
            }
            return islandGroup;
        }

        function createOldTree() {
            const treeGroup = new THREE.Group();
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A3024, 
                roughness: 0.92, metalness: 0.02, flatShading: true });
            const foliageMaterial = new THREE.MeshStandardMaterial({
                color: 0x2E5212, 
                roughness: 0.88, metalness: 0.0, flatShading: true });

            const topTrunkRadius = 2.5;     
            const numTrunkSegments = 8;     
            let currentSegmentYOffset = 0;
            let previousSegmentTopRadius = baseTrunkRadius;

            for (let i = 0; i < numTrunkSegments; i++) {
                const segmentHeight = overallTrunkHeight / numTrunkSegments;
                const segmentRadiusBottom = previousSegmentTopRadius;
                const t = (i + 1) / numTrunkSegments;
                const segmentRadiusTop = THREE.MathUtils.lerp(baseTrunkRadius, topTrunkRadius, t);
                const trunkSegmentGeo = new THREE.CylinderGeometry(segmentRadiusTop, segmentRadiusBottom, segmentHeight, 14, 4); 
                const trunkSegmentMesh = new THREE.Mesh(trunkSegmentGeo, trunkMaterial);
                trunkSegmentMesh.castShadow = true; trunkSegmentMesh.receiveShadow = true;
                trunkSegmentMesh.position.y = currentSegmentYOffset + segmentHeight / 2;
                if (i > 0) { 
                    trunkSegmentMesh.position.x += (Math.random() - 0.5) * baseTrunkRadius * 0.07; 
                    trunkSegmentMesh.position.z += (Math.random() - 0.5) * baseTrunkRadius * 0.07;
                    trunkSegmentMesh.rotation.y += (Math.random() - 0.5) * 0.10;
                    trunkSegmentMesh.rotation.x += (Math.random() - 0.5) * 0.04;
                    trunkSegmentMesh.rotation.z += (Math.random() - 0.5) * 0.04;
                }
                treeGroup.add(trunkSegmentMesh);
                currentSegmentYOffset += segmentHeight;
                previousSegmentTopRadius = segmentRadiusTop;
            }

            const numRoots = 8; 
            const rootLength = 14.0; 
            const rootBaseRadius = 2.2; 
            const rootTipRadius = 0.35;
            for (let i = 0; i < numRoots; i++) {
                const rootGeo = new THREE.CylinderGeometry(rootTipRadius, rootBaseRadius, rootLength, 12, 1); 
                const rootMesh = new THREE.Mesh(rootGeo, trunkMaterial);
                rootMesh.castShadow = true; rootMesh.receiveShadow = true;
                const angle = (i / numRoots) * Math.PI * 2 + (Math.random() - 0.5) * 0.30;
                const distanceFromTrunkCenter = baseTrunkRadius * 0.8; 
                rootMesh.position.set(
                    Math.cos(angle) * distanceFromTrunkCenter,
                    -rootLength * 0.25, 
                    Math.sin(angle) * distanceFromTrunkCenter
                );
                rootMesh.rotation.y = -angle + Math.PI / 2;
                rootMesh.rotation.z = Math.PI / 2.0 + (Math.random() - 0.5) * 0.15; 
                rootMesh.rotation.x = (Math.random() - 0.5) * 0.10;
                treeGroup.add(rootMesh);
            }

            const branchLength = 18.0; 
            const branchRadiusBottom = 2.2; 
            const branchRadiusTop = 1.1; 
            const branchGroup = new THREE.Group();
            const branchGeometry = new THREE.CylinderGeometry(branchRadiusTop, branchRadiusBottom, branchLength, 12, 3); 
            const branchMesh = new THREE.Mesh(branchGeometry, trunkMaterial);
            branchMesh.castShadow = true; branchMesh.receiveShadow = true;
            branchMesh.position.y = branchLength / 2;
            branchGroup.add(branchMesh);
            branchGroup.position.set(
                previousSegmentTopRadius * 0.35, 
                overallTrunkHeight * 0.55, 
                0
            );
            branchGroup.rotation.z = -Math.PI / 6.5; 
            branchGroup.rotation.y = Math.PI / 9;   
            treeGroup.add(branchGroup);

            function createFoliageClump(size, numLeaves) {
                const clump = new THREE.Group();
                for (let i = 0; i < numLeaves; i++) {
                    const leafSize = size * (Math.random() * 0.55 + 0.70); 
                    const leafGeometry = new THREE.IcosahedronGeometry(leafSize, Math.floor(Math.random()*2)); 
                    const leafMesh = new THREE.Mesh(leafGeometry, foliageMaterial);
                    leafMesh.castShadow = true; 
                    leafMesh.position.set(
                        (Math.random() - 0.5) * size * 1.8, 
                        (Math.random() - 0.5) * size * 1.8,
                        (Math.random() - 0.5) * size * 1.8
                    );
                    leafMesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    clump.add(leafMesh);
                }
                return clump;
            }

            const topFoliage = createFoliageClump(10.0, 60); 
            topFoliage.position.y = overallTrunkHeight + 4.0; 
            treeGroup.add(topFoliage);

            const branchTipLocator = new THREE.Object3D();
            branchTipLocator.position.y = branchLength; branchGroup.add(branchTipLocator);
            const branchMidLocator = new THREE.Object3D();
            branchMidLocator.position.y = branchLength * 0.55; branchGroup.add(branchMidLocator);
            const worldPos = new THREE.Vector3(); 

            branchTipLocator.getWorldPosition(worldPos);
            const branchFoliage = createFoliageClump(7.0, 40); 
            branchFoliage.position.copy(treeGroup.worldToLocal(worldPos.clone())); 
            treeGroup.add(branchFoliage);

            branchMidLocator.getWorldPosition(worldPos);
            const midBranchFoliage = createFoliageClump(5.5, 28); 
            midBranchFoliage.position.copy(treeGroup.worldToLocal(worldPos.clone()));
            midBranchFoliage.position.y += 1.2; 
            treeGroup.add(midBranchFoliage);
            
            branchGroup.remove(branchTipLocator); branchGroup.remove(branchMidLocator);
            return treeGroup;
        }

        function createWiseReader() {
            const readerGroup = new THREE.Group();
            const flatShading = true;
            const roughness = 0.85;
            const characterOverallScale = 0.85; 

            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x3B4A6B, roughness: roughness, flatShading: flatShading }); 
            const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xBCA080, roughness: roughness, flatShading: flatShading });
            const bookCoverMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: roughness, flatShading: flatShading }); 
            const bookPageMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: roughness, flatShading: flatShading }); 
            const beardMaterial = new THREE.MeshStandardMaterial({ color: 0xDCDCDC, roughness: roughness, flatShading: flatShading });
            const handMaterial = skinMaterial;

            const lowerBodyWidth = 2.0;
            const lowerBodyHeight = 1.5; 
            const lowerBodyDepth = 2.2;
            const lowerBodyGeometry = new THREE.BoxGeometry(lowerBodyWidth, lowerBodyHeight, lowerBodyDepth);
            const lowerBodyMesh = new THREE.Mesh(lowerBodyGeometry, robeMaterial);
            lowerBodyMesh.position.y = lowerBodyHeight / 2; 
            lowerBodyMesh.castShadow = true;
            lowerBodyMesh.receiveShadow = true;
            readerGroup.add(lowerBodyMesh);

            const torsoHeight = 2.3;
            const torsoTopRadius = 0.8;
            const torsoBottomRadius = 1.0;
            const torsoGeometry = new THREE.CylinderGeometry(torsoTopRadius, torsoBottomRadius, torsoHeight, 10);
            const torsoMesh = new THREE.Mesh(torsoGeometry, robeMaterial);
            torsoMesh.position.y = lowerBodyHeight + torsoHeight / 2 - 0.2;
            torsoMesh.position.z = -0.3; 
            torsoMesh.rotation.x = THREE.MathUtils.degToRad(-10); 
            torsoMesh.castShadow = true;
            torsoMesh.receiveShadow = true;
            readerGroup.add(torsoMesh);

            const headRadius = 1.0;
            const headGeometry = new THREE.SphereGeometry(headRadius, 10, 8);
            const headMesh = new THREE.Mesh(headGeometry, skinMaterial);
            const torsoTopCenterY = torsoMesh.position.y + (torsoHeight / 2) * Math.cos(torsoMesh.rotation.x);
            const torsoTopCenterZ = torsoMesh.position.z - (torsoHeight / 2) * Math.sin(torsoMesh.rotation.x);
            headMesh.position.y = torsoTopCenterY + headRadius * 0.6 * Math.cos(torsoMesh.rotation.x);
            headMesh.position.z = torsoTopCenterZ - headRadius * 0.6 * Math.sin(torsoMesh.rotation.x) - headRadius * 0.1;
            headMesh.rotation.x = THREE.MathUtils.degToRad(15); 
            headMesh.castShadow = true;
            headMesh.receiveShadow = true;
            readerGroup.add(headMesh);

            const beardHeight = 1.6;
            const beardRadius = 0.7;
            const beardGeometry = new THREE.ConeGeometry(beardRadius, beardHeight, 8);
            const beardMesh = new THREE.Mesh(beardGeometry, beardMaterial);
            beardMesh.position.set(
                headMesh.position.x, 
                headMesh.position.y - headRadius * 0.45, 
                headMesh.position.z + headRadius * 0.60  
            );
            beardMesh.rotation.x = headMesh.rotation.x + THREE.MathUtils.degToRad(15); 
            beardMesh.castShadow = true;
            readerGroup.add(beardMesh);

            const handRadius = 0.4;
            const handGeometry = new THREE.SphereGeometry(handRadius, 6, 5);

            const leftHandMesh = new THREE.Mesh(handGeometry, handMaterial);
            leftHandMesh.position.set(
                -torsoTopRadius * 0.6, 
                lowerBodyHeight + 0.5,  
                lowerBodyDepth * 0.30  
            );
            leftHandMesh.castShadow = true;
            readerGroup.add(leftHandMesh);

            const rightHandMesh = new THREE.Mesh(handGeometry, handMaterial);
            rightHandMesh.position.set(
                torsoTopRadius * 0.6,
                lowerBodyHeight + 0.5,
                lowerBodyDepth * 0.30
            );
            rightHandMesh.castShadow = true;
            readerGroup.add(rightHandMesh);

            const bookWidth = 1.8;
            const bookThickness = 0.3; 
            const bookDepthDim = 1.4; 
            const bookGroup = new THREE.Group(); 
            const bookCoverGeometry = new THREE.BoxGeometry(bookWidth, bookThickness, bookDepthDim);
            const bookCoverMesh = new THREE.Mesh(bookCoverGeometry, bookCoverMaterial);
            bookCoverMesh.castShadow = true;
            bookCoverMesh.receiveShadow = true;
            bookGroup.add(bookCoverMesh);
            const pageThickness = bookThickness * 0.8;
            const pageWidth = bookWidth * 0.95;
            const pageDepthDim = bookDepthDim * 0.95;
            const pageGeometry = new THREE.BoxGeometry(pageWidth, pageThickness, pageDepthDim);
            const pageMesh = new THREE.Mesh(pageGeometry, bookPageMaterial);
            pageMesh.position.y = bookThickness * 0.05; 
            bookGroup.add(pageMesh);
            bookGroup.position.set(
                0, 
                lowerBodyHeight + 0.6, 
                lowerBodyDepth * 0.25 
            );
            bookGroup.rotation.x = THREE.MathUtils.degToRad(-45); 
            bookGroup.rotation.y = THREE.MathUtils.degToRad(5);  
            readerGroup.add(bookGroup);

            readerGroup.scale.set(characterOverallScale, characterOverallScale, characterOverallScale);
            return readerGroup;
        }

        // --- Link Orb Creation ---
        function createLinkOrb(url, name, color = 0xFFD700, size = 2.0) { // Default size increased
            const orbGroup = new THREE.Group();
            orbGroup.userData.originalScale = new THREE.Vector3(1, 1, 1); // Store initial scale for hover effect

            const orbGeometry = new THREE.SphereGeometry(size, 16, 12);
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 2.0, 
                roughness: 0.1,         
                metalness: 0.3,         
                flatShading: false 
            });
            const orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);
            orbMesh.castShadow = true; 

            orbMesh.userData.isLinkOrb = true;
            orbMesh.userData.url = url;
            orbMesh.userData.name = name;
            orbGroup.add(orbMesh);

            const pointLight = new THREE.PointLight(color, 3.0, 18 + size * 2); 
            pointLight.position.set(0, 0, 0); 
            orbMesh.add(pointLight); 

            linkOrbs.push(orbMesh); 
            return orbGroup;
        }

        function createLinkOrbs() {
            const treeBaseYOnIsland = tree.position.y; 
            const foliageTopRelativeToTreeBase = foliageClumpTopY; 
            const absoluteFoliageTopY = treeBaseYOnIsland + foliageTopRelativeToTreeBase;
            
            const orbBaseHeight = absoluteFoliageTopY + 12; // Increased base height for orbs (farther from tree tops)

            const linkData = [ // Sizes increased
                { name: "Three.js Journey", url: "https://threejs-journey.com/", color: 0xFFD700, size: 2.5 },
                { name: "Discover Three.js", url: "https://discoverthreejs.com/", color: 0xFFB800, size: 2.2 },
                { name: "Sketchfab", url: "https://sketchfab.com/feed", color: 0xFFA500, size: 2.6 },
                { name: "Poly Haven", url: "https://polyhaven.com/", color: 0xFFC840, size: 2.3 },
                { name: "Google Arts", url: "https://artsandculture.google.com/", color: 0xFFE066, size: 2.55 },
                { name: "Shadertoy", url: "https://www.shadertoy.com/", color: 0xFF8C00, size: 2.35 },
                { name: "ArtStation", url: "https://www.artstation.com/", color: 0xFFDAB9, size: 2.25 },
                { name: "Codepen", url: "https://codepen.io/", color: 0xDAA520, size: 2.5 },
                { name: "GitHub", url: "https://github.com/", color: 0xBDB76B, size: 2.1 },
                { name: "Blender", url: "https://www.blender.org/", color: 0xFFA07A, size: 2.6 },
                { name: "Mozilla Developer", url: "https://developer.mozilla.org/", color: 0xADD8E6, size: 2.2 }
            ];

            linkData.forEach((data, index) => {
                const orb = createLinkOrb(data.url, data.name, data.color, data.size); 
                
                const angle = (index / linkData.length) * Math.PI * 2 + (Math.random() - 0.5) * 0.7; // More spread
                const distanceFromTrunk = baseTrunkRadius + 10 + Math.random() * 15; // Scatter further
                
                const orbX = Math.cos(angle) * distanceFromTrunk;
                const orbZ = Math.sin(angle) * distanceFromTrunk;
                const orbY = orbBaseHeight + (Math.random() - 0.5) * 12; // More vertical scatter

                orb.position.set(
                    tree.position.x + orbX, 
                    orbY,                   
                    tree.position.z + orbZ 
                );
                island.add(orb); 
            });
        }
        
        // --- Mouse Interaction for Orbs (Click and Hover) ---
        function onDocumentMouseDown(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(linkOrbs, false); 
            if (intersects.length > 0) {
                const firstIntersectedObject = intersects[0].object;
                if (firstIntersectedObject.userData.isLinkOrb && firstIntersectedObject.userData.url) {
                    window.open(firstIntersectedObject.userData.url, '_blank');
                    showMessage(`Opening: ${firstIntersectedObject.userData.name}`, 2000);
                }
            }
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(linkOrbs, false);

            if (intersects.length > 0) {
                const intersectedMesh = intersects[0].object;
                if (intersectedMesh.userData.isLinkOrb) {
                    const targetOrbGroup = intersectedMesh.parent; // The group is what we scale
                    if (currentHoveredOrbGroup !== targetOrbGroup) {
                        if (currentHoveredOrbGroup && currentHoveredOrbGroup.userData.originalScale) {
                            currentHoveredOrbGroup.scale.copy(currentHoveredOrbGroup.userData.originalScale);
                        }
                        currentHoveredOrbGroup = targetOrbGroup;
                        if (currentHoveredOrbGroup.userData.originalScale) { // Ensure originalScale is set
                           currentHoveredOrbGroup.scale.copy(currentHoveredOrbGroup.userData.originalScale).multiplyScalar(hoverScaleFactor);
                        }
                        document.body.style.cursor = 'pointer';
                    }
                } else { // Intersected something that is not a link orb
                    if (currentHoveredOrbGroup && currentHoveredOrbGroup.userData.originalScale) {
                        currentHoveredOrbGroup.scale.copy(currentHoveredOrbGroup.userData.originalScale);
                        currentHoveredOrbGroup = null;
                        document.body.style.cursor = 'default';
                    }
                }
            } else { // No intersections
                if (currentHoveredOrbGroup && currentHoveredOrbGroup.userData.originalScale) {
                    currentHoveredOrbGroup.scale.copy(currentHoveredOrbGroup.userData.originalScale);
                    currentHoveredOrbGroup = null;
                    document.body.style.cursor = 'default';
                }
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        const clock = new THREE.Clock(); 

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); 

            if (skyBackground && skyBackground.material.uniforms.iTime) { 
                 skyBackground.material.uniforms.iTime.value += delta * 0.5; 
            }

            linkOrbs.forEach(orbMesh => { // orbMesh is the sphere mesh, its parent is the group
                const orbGroup = orbMesh.parent;
                if (orbGroup) { 
                    const bobbleFactor = orbGroup.id * 0.1 + 0.7; 
                    orbGroup.position.y += Math.sin(clock.elapsedTime * (1.0 + bobbleFactor) + orbGroup.id * 0.5) * 0.005; 
                    orbGroup.rotation.y += delta * (0.03 + Math.sin(clock.elapsedTime * 0.2 + orbGroup.id * 0.3) * 0.03) ;
                }
            });


            controls.update();
            renderer.render(scene, camera);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
