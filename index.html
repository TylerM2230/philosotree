<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Philosotree - Interactive Tree of Philosophical Wisdom
    </title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Inter", sans-serif;
        background-color: #000; /* Body background, canvas will overlay */
      }
      canvas {
        display: block;
      }
      .message-box {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 16px;
        z-index: 100;
        display: none;
        text-align: center;
      }
    </style>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="messageBox" class="message-box"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let scene, camera, renderer, controls;
      let island, tree;
      const islandBaseRadius = 16;
      let skyBackground;
      const baseTrunkRadius = 4.2;
      const overallTrunkHeight = 35;
      const foliageClumpTopY = overallTrunkHeight + 4.0 + 10.0 * 0.9;

      let linkOrbs = []; // Will store the orb meshes (not groups) for shimmer animation
      let linkOrbGroups = []; // Will store the orb groups for bobbing animation

      let raycaster, mouse;
      let currentHoveredOrbGroup = null; 
      const hoverScaleFactor = 1.2;

      // Mobile detection and performance settings
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
      const isLowEnd = isMobile || navigator.hardwareConcurrency <= 4;
      
      // Performance settings based on device
      const performanceSettings = {
        shadowMapSize: isMobile ? 1024 : 4096,
        foliageCount: isMobile ? 30 : 60,
        branchFoliageCount: isMobile ? 20 : 40,
        midBranchFoliageCount: isMobile ? 15 : 28,
        geometrySegments: isMobile ? 8 : 14,
        skySegments: isMobile ? 64 : 128,
        skyRings: isMobile ? 32 : 64,
        smallRocksCount: isMobile ? 8 : 16,
        pixelRatio: isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio,
        antialias: !isLowEnd
      };

      // Vertex Shader for the sky (remains the same)
      const skyVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

      // Fragment Shader for a Night Sky with Simplex Noise Galaxy (Optimized for mobile)
      const nightSkyFragmentShader = `
            varying vec2 vUv;
            uniform float iTime;
            uniform bool isMobile;

            // --- Simplex Noise 2D - Stefan Gustavson's implementation ---
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m; m = m*m;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= (1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ));
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
            // --- End Simplex Noise 2D ---

            // --- Fractional Brownian Motion (FBM) using Simplex Noise (Optimized) ---
            float fbm_simplex(vec2 p, int octaves, float persistence, float lacunarity, float initial_scale, float time_offset) {
                float total = 0.0;
                float frequency = initial_scale;
                float amplitude = 1.0;
                float maxValue = 0.0; 
                // Reduce octaves on mobile for performance
                int maxOctaves = isMobile ? min(octaves, 3) : octaves;
                for (int i = 0; i < maxOctaves; i++) {
                    total += snoise(vec2(p.x * frequency + time_offset, p.y * frequency - time_offset * 0.3)) * amplitude; 
                    maxValue += amplitude;
                    amplitude *= persistence; 
                    frequency *= lacunarity;  
                }
                return (total / maxValue) * 0.5 + 0.5; 
            }
            // --- End FBM ---

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
            }

            float starShape(vec2 coord, float radius, float blur) {
                return 1.0 - smoothstep(radius - blur, radius + blur, length(coord));
            }

            void main() {
                // Base sky color: Rich, dark indigo/blue.
                vec3 color = vec3(0.02, 0.01, 0.06); 

                // --- Flowing Galaxy/Nebula Layers using Simplex Noise FBM ---
                vec2 baseUv = vUv; 
                
                int octaves = isMobile ? 3 : 5;          
                float persistence = 0.48; 
                float lacunarity = 2.1;   

                float time1 = iTime * 0.01; 
                float fbmVal1 = fbm_simplex(baseUv * 0.75, octaves, persistence, lacunarity, 1.2, time1); 
                fbmVal1 = smoothstep(0.35, 0.65, fbmVal1); 

                float time2 = iTime * 0.018; 
                vec2 uv2 = baseUv * 1.2 + vec2(0.04 + sin(iTime * 0.0075) * 0.03, -0.025 + cos(iTime*0.0055)*0.025); 
                float fbmVal2 = fbm_simplex(uv2, octaves, persistence * 0.85, lacunarity, 2.4, time2); 
                fbmVal2 = smoothstep(0.38, 0.68, fbmVal2);

                float nebulaDensity = fbmVal1 * 0.7 + fbmVal2 * 0.6; 
                nebulaDensity = pow(clamp(nebulaDensity, 0.0, 1.0), 1.6); 

                // Nebula Colors: Vibrant blues, magentas, and purples
                vec3 nebulaColorDeepPurple = vec3(0.2, 0.05, 0.45);  // Rich deep purple
                vec3 nebulaColorMagenta = vec3(0.7, 0.1, 0.55);    // Vibrant magenta
                vec3 nebulaColorBrightBlue = vec3(0.15, 0.3, 0.8);  // Bright, saturated blue
                vec3 nebulaColorHotPink = vec3(0.9, 0.25, 0.6);   // Hot pink/violet highlights

                vec3 nebulaContribution = vec3(0.0);
                nebulaContribution = mix(nebulaContribution, nebulaColorDeepPurple, nebulaDensity * 0.6);
                nebulaContribution = mix(nebulaContribution, nebulaColorMagenta, pow(nebulaDensity, 1.4) * 0.5);
                nebulaContribution = mix(nebulaContribution, nebulaColorBrightBlue, pow(nebulaDensity, 2.2) * 0.4);
                nebulaContribution = mix(nebulaContribution, nebulaColorHotPink, pow(nebulaDensity, 3.5) * 0.35);
                
                color += nebulaContribution * 1.3; // Increased nebula brightness contribution

                // --- Star Layers (Reduced density on mobile) ---
                float starDensityMultiplier = isMobile ? 0.7 : 1.0;
                
                vec2 st1 = vUv * vec2(250.0 * starDensityMultiplier, 125.0 * starDensityMultiplier); 
                vec2 ipos1 = floor(st1);
                vec2 fpos1 = fract(st1) - 0.5; 
                float rnd1 = random(ipos1);

                float starThreshold1 = isMobile ? 0.988 : 0.986;
                if (rnd1 > starThreshold1) { 
                    float baseStarSize = (random(ipos1 + 0.1) * 0.028 + 0.013) * ( (1.0-vUv.y) * 0.5 + 0.5); 
                    float throbSpeed = random(ipos1 + 0.15) * 1.4 + 0.45;
                    float throbPhase = random(ipos1 + 0.18) * 6.28;
                    float throbAmount = (sin(iTime * throbSpeed + throbPhase) * 0.18 + 0.82); 
                    float starSize = baseStarSize * throbAmount;
                    float starBlur = starSize * 0.55; 
                    float starMask = starShape(fpos1, starSize, starBlur);
                    
                    if (starMask > 0.0) {
                        float starIntensity = pow((rnd1 - starThreshold1) / (1.0 - starThreshold1), 1.9) * 0.75 + 0.2; 
                        float twinkleSpeed = random(ipos1 + 0.2) * 2.2 + 0.7;
                        float twinklePhase = random(ipos1 + 0.3) * 6.28;
                        float twinkle = (sin(iTime * twinkleSpeed + twinklePhase) * 0.4 + 0.6); 
                        vec3 starBaseColor = vec3(0.92, 0.92, 1.0); 
                        vec3 starColorVariation = (vec3(random(ipos1 + 0.4), random(ipos1 + 0.5), random(ipos1 + 0.6)) - 0.5) * 0.2;
                        vec3 finalStarColor = starBaseColor + starColorVariation;
                        color += finalStarColor * starIntensity * twinkle * starMask * 0.65; 
                    }
                }

                vec2 st2 = vUv * vec2(100.0 * starDensityMultiplier, 50.0 * starDensityMultiplier); 
                vec2 ipos2 = floor(st2);
                vec2 fpos2 = fract(st2) - 0.5;
                float rnd2 = random(ipos2);

                float starThreshold2 = isMobile ? 0.995 : 0.993;
                if (rnd2 > starThreshold2) { 
                    float baseStarSize = (random(ipos2 + 0.15) * 0.038 + 0.022) * ( (1.0-vUv.y) * 0.4 + 0.6); 
                    float throbSpeed = random(ipos2 + 0.17) * 1.1 + 0.35;
                    float throbPhase = random(ipos2 + 0.19) * 6.28;
                    float throbAmount = (sin(iTime * throbSpeed + throbPhase) * 0.22 + 0.78); 
                    float starSize = baseStarSize * throbAmount;
                    float starBlur = starSize * 0.45; 
                    float starMask = starShape(fpos2, starSize, starBlur);

                    if (starMask > 0.0) {
                        float starIntensity = pow((rnd2 - starThreshold2) / (1.0 - starThreshold2), 1.7) * 0.65 + 0.3;
                        float twinkleSpeed = random(ipos2 + 0.25) * 1.9 + 0.45;
                        float twinklePhase = random(ipos2 + 0.35) * 6.28;
                        float twinkle = (sin(iTime * twinkleSpeed + twinklePhase) * 0.35 + 0.65);
                        vec3 starBaseColor = vec3(0.98, 0.95, 0.92); 
                        vec3 starColorVariation = (vec3(random(ipos2 + 0.45), random(ipos2 + 0.55), random(ipos2 + 0.65)) - 0.5) * 0.1;
                        vec3 finalStarColor = starBaseColor + starColorVariation;
                        color += finalStarColor * starIntensity * twinkle * starMask * 0.8; 
                    }
                }
                
                color = clamp(color, 0.0, 1.0); 
                gl_FragColor = vec4(color, 1.0);
            }
        `;

      function showMessage(message, duration = 3000) {
        const messageBox = document.getElementById("messageBox");
        if (messageBox) {
          messageBox.textContent = message;
          messageBox.style.display = "block";
          setTimeout(() => {
            messageBox.style.display = "none";
          }, duration);
        } else {
          console.log("Message box not found, original message:", message);
        }
      }

      function init() {
        try {
          // Scene
          scene = new THREE.Scene();
          scene.fog = new THREE.Fog(0x181028, 140, 680); // Richer dark purple fog

          // Starry Night Sky Background (Optimized geometry)
          const skyGeometry = new THREE.SphereGeometry(1200, performanceSettings.skySegments, performanceSettings.skyRings); 
          const skyMaterial = new THREE.ShaderMaterial({
            vertexShader: skyVertexShader,
            fragmentShader: nightSkyFragmentShader, 
            uniforms: {
              iTime: { value: 0.0 },
              isMobile: { value: isMobile },
            },
            side: THREE.BackSide,
            depthWrite: false,
          });
          skyBackground = new THREE.Mesh(skyGeometry, skyMaterial);
          scene.add(skyBackground);

          // Camera
          camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            2200 
          );
          camera.position.set(60, 55, 110);

          // Renderer (Optimized for mobile)
          renderer = new THREE.WebGLRenderer({ 
            antialias: performanceSettings.antialias,
            powerPreference: isMobile ? "low-power" : "high-performance"
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(performanceSettings.pixelRatio);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = isMobile ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
          renderer.toneMapping = THREE.ACESFilmicToneMapping;
          renderer.toneMappingExposure = 0.8; // Maintained exposure for vibrancy
          document.body.appendChild(renderer.domElement);

          // Controls
          controls = new OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.screenSpacePanning = false;
          controls.minDistance = 30;
          controls.maxDistance = 550;
          controls.maxPolarAngle = Math.PI / 1.7;

          // Lighting (Optimized)
          const ambientLight = new THREE.AmbientLight(0x9090B0, 1.25); // Adjusted ambient for golden orbs
          scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xFFE0C0, 1.55); // Warmer directional for golden orbs
          directionalLight.position.set(70, 100, 100);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = performanceSettings.shadowMapSize;
          directionalLight.shadow.mapSize.height = performanceSettings.shadowMapSize;
          directionalLight.shadow.camera.near = 1;
          directionalLight.shadow.camera.far = 450;
          const shadowCamSize = 140;
          directionalLight.shadow.camera.left = -shadowCamSize;
          directionalLight.shadow.camera.right = shadowCamSize;
          directionalLight.shadow.camera.top = shadowCamSize;
          directionalLight.shadow.camera.bottom = -shadowCamSize;
          directionalLight.shadow.bias = -0.0005;
          scene.add(directionalLight);

          // Create elements
          island = createFloatingIsland();
          island.position.y = -22;
          scene.add(island);

          tree = createOldTree();
          tree.position.y = 12.5;
          island.add(tree);

          const wiseReader = createWiseReader();
          const readerOverallScale = 0.85;
          const lowerBodyDepth = 2.2 * readerOverallScale;
          const readerCenterToBack =
            lowerBodyDepth / 2 + 0.3 * readerOverallScale;

          const readerAngle = Math.PI / 4; 
          const readerDistFromTrunk =
            baseTrunkRadius + readerCenterToBack - 0.7;

          wiseReader.position.set(
            tree.position.x + Math.cos(readerAngle) * readerDistFromTrunk,
            13.2,
            tree.position.z + Math.sin(readerAngle) * readerDistFromTrunk
          );
          wiseReader.rotation.y = readerAngle;
          island.add(wiseReader);

          createLinkOrbs();

          raycaster = new THREE.Raycaster();
          mouse = new THREE.Vector2();
          renderer.domElement.addEventListener(
            "mousedown",
            onDocumentMouseDown,
            false
          );
          renderer.domElement.addEventListener(
            "mousemove",
            onDocumentMouseMove,
            false
          );

          window.addEventListener("resize", onWindowResize, false);
          animate();
          showMessage(
            "Click the golden orbs to explore philosophical wisdom",
            6000
          );
        } catch (error) {
          console.error("Error during initialization:", error);
          showMessage(
            "Error initializing 3D scene. Check console for details.",
            5000
          );
        }
      }

      function createFloatingIsland() {
        const islandGroup = new THREE.Group();
        const earthMaterial = new THREE.MeshStandardMaterial({
          color: 0x6a4030,
          roughness: 0.9,
          metalness: 0.02,
          flatShading: true,
        });
        const grassMaterial = new THREE.MeshStandardMaterial({
          color: 0x407a00,
          roughness: 0.93,
          metalness: 0.0,
          flatShading: true,
        });

        const earthHeight = 20;
        const earthTopRadius = islandBaseRadius * 1.15;
        const earthBottomRadius = islandBaseRadius * 0.75;
        const radialSegments = isMobile ? 20 : 28; // Reduced for mobile
        const heightSegments = isMobile ? 6 : 10;  // Reduced for mobile

        const baseEarthGeom = new THREE.CylinderGeometry(
          earthTopRadius,
          earthBottomRadius,
          earthHeight,
          radialSegments,
          heightSegments
        );
        const positions = baseEarthGeom.attributes.position;
        const normals = baseEarthGeom.attributes.normal;

        const organicScale = 2.5;
        const warpFrequency = 0.2;
        const warpAmplitude = islandBaseRadius * 0.3;

        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const y = positions.getY(i);
          const z = positions.getZ(i);
          const angle = Math.atan2(z, x);
          const warpFactor =
            (Math.sin(angle * 3.0 + y * warpFrequency) +
              Math.cos(angle * 2.0 - y * warpFrequency * 0.7)) *
            0.5;
          const warpOffsetX = Math.cos(angle) * warpAmplitude * warpFactor;
          const warpOffsetZ = Math.sin(angle) * warpAmplitude * warpFactor;
          let currentX = x + warpOffsetX;
          let currentZ = z + warpOffsetZ;
          const horizontalInfluence =
            Math.sqrt(currentX * currentX + currentZ * currentZ) /
            (earthTopRadius + warpAmplitude);
          const randomFactor =
            (Math.random() - 0.5) * organicScale * horizontalInfluence;
          const nx = normals.getX(i);
          const nz = normals.getZ(i);
          if (y > -earthHeight / 2 + 0.1) {
            currentX +=
              nx * randomFactor * (1 + Math.abs(y / (earthHeight / 2)) * 0.7);
            currentZ +=
              nz * randomFactor * (1 + Math.abs(y / (earthHeight / 2)) * 0.7);
          }
          positions.setX(i, currentX);
          positions.setZ(i, currentZ);
          if (Math.abs(y) < earthHeight / 2 - 0.1) {
            positions.setY(
              i,
              y +
                (Math.random() - 0.5) *
                  organicScale *
                  0.4 *
                  horizontalInfluence *
                  (1.0 - Math.abs(y / (earthHeight / 2)))
            );
          }
        }
        baseEarthGeom.computeVertexNormals();
        const earthMesh = new THREE.Mesh(baseEarthGeom, earthMaterial);
        earthMesh.castShadow = true;
        earthMesh.receiveShadow = true;
        islandGroup.add(earthMesh);

        const grassHeight = 4.0;
        const grassCapGeom = new THREE.CylinderGeometry(
          earthTopRadius * 1.08,
          earthTopRadius * 1.04,
          grassHeight,
          radialSegments,
          2
        );
        const grassPositions = grassCapGeom.attributes.position;
        for (let i = 0; i < grassPositions.count; i++) {
          const x = grassPositions.getX(i);
          const y = grassPositions.getY(i);
          const z = grassPositions.getZ(i);
          const angle = Math.atan2(z, x);
          const warpFactor =
            (Math.sin(angle * 3.0 + y * warpFrequency * 0.5) +
              Math.cos(angle * 2.0 - y * warpFrequency * 0.35)) *
            0.5;
          const warpOffsetX =
            Math.cos(angle) * warpAmplitude * 0.3 * warpFactor;
          const warpOffsetZ =
            Math.sin(angle) * warpAmplitude * 0.3 * warpFactor;
          grassPositions.setX(i, x + warpOffsetX + (Math.random() - 0.5) * 0.7);
          grassPositions.setZ(i, z + warpOffsetZ + (Math.random() - 0.5) * 0.7);
          if (y > grassHeight / 2 - 0.1) {
            grassPositions.setY(i, y + (Math.random() - 0.5) * 0.6);
          }
        }
        grassCapGeom.computeVertexNormals();
        const grassMesh = new THREE.Mesh(grassCapGeom, grassMaterial);
        grassMesh.position.y = earthHeight / 2 + grassHeight / 2 - 0.8;
        grassMesh.castShadow = true;
        grassMesh.receiveShadow = true;
        islandGroup.add(grassMesh);

        const numSmallRocks = performanceSettings.smallRocksCount;
        for (let i = 0; i < numSmallRocks; i++) {
          const rockSize = Math.random() * 4.5 + 2.0;
          const rockGeom = new THREE.IcosahedronGeometry(
            rockSize,
            Math.floor(Math.random() * 2)
          );
          const rockMesh = new THREE.Mesh(rockGeom, earthMaterial);
          const angle = Math.random() * Math.PI * 2;
          const radiusFactor = 1.0 + (Math.random() - 0.5) * 0.4;
          const distance =
            (earthTopRadius + warpAmplitude) * radiusFactor +
            Math.random() * 18 +
            12;
          rockMesh.position.set(
            Math.cos(angle) * distance,
            Math.random() * 10 - 18,
            Math.sin(angle) * distance
          );
          rockMesh.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );
          rockMesh.castShadow = true;
          rockMesh.receiveShadow = true;
          islandGroup.add(rockMesh);
        }
        return islandGroup;
      }

      function createOldTree() {
        const treeGroup = new THREE.Group();
        const trunkMaterial = new THREE.MeshStandardMaterial({
          color: 0x4a3024,
          roughness: 0.92,
          metalness: 0.02,
          flatShading: true,
        });
        const foliageMaterial = new THREE.MeshStandardMaterial({
          color: 0x2e5212,
          roughness: 0.88,
          metalness: 0.0,
          flatShading: true,
        });

        const topTrunkRadius = 2.5;
        const numTrunkSegments = 8;
        let currentSegmentYOffset = 0;
        let previousSegmentTopRadius = baseTrunkRadius;

        for (let i = 0; i < numTrunkSegments; i++) {
          const segmentHeight = overallTrunkHeight / numTrunkSegments;
          const segmentRadiusBottom = previousSegmentTopRadius;
          const t = (i + 1) / numTrunkSegments;
          const segmentRadiusTop = THREE.MathUtils.lerp(
            baseTrunkRadius,
            topTrunkRadius,
            t
          );
          const trunkSegmentGeo = new THREE.CylinderGeometry(
            segmentRadiusTop,
            segmentRadiusBottom,
            segmentHeight,
            performanceSettings.geometrySegments, // Optimized for mobile
            4
          );
          const trunkSegmentMesh = new THREE.Mesh(
            trunkSegmentGeo,
            trunkMaterial
          );
          trunkSegmentMesh.castShadow = true;
          trunkSegmentMesh.receiveShadow = true;
          trunkSegmentMesh.position.y =
            currentSegmentYOffset + segmentHeight / 2;
          if (i > 0) {
            trunkSegmentMesh.position.x +=
              (Math.random() - 0.5) * baseTrunkRadius * 0.07;
            trunkSegmentMesh.position.z +=
              (Math.random() - 0.5) * baseTrunkRadius * 0.07;
            trunkSegmentMesh.rotation.y += (Math.random() - 0.5) * 0.1;
            trunkSegmentMesh.rotation.x += (Math.random() - 0.5) * 0.04;
            trunkSegmentMesh.rotation.z += (Math.random() - 0.5) * 0.04;
          }
          treeGroup.add(trunkSegmentMesh);
          currentSegmentYOffset += segmentHeight;
          previousSegmentTopRadius = segmentRadiusTop;
        }

        const numRoots = 8;
        const rootLength = 14.0;
        const rootBaseRadius = 2.2;
        const rootTipRadius = 0.35;
        for (let i = 0; i < numRoots; i++) {
          const rootGeo = new THREE.CylinderGeometry(
            rootTipRadius,
            rootBaseRadius,
            rootLength,
            isMobile ? 8 : 12, // Reduced for mobile
            1
          );
          const rootMesh = new THREE.Mesh(rootGeo, trunkMaterial);
          rootMesh.castShadow = true;
          rootMesh.receiveShadow = true;
          const angle =
            (i / numRoots) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
          const distanceFromTrunkCenter = baseTrunkRadius * 0.8;
          rootMesh.position.set(
            Math.cos(angle) * distanceFromTrunkCenter,
            -rootLength * 0.25,
            Math.sin(angle) * distanceFromTrunkCenter
          );
          rootMesh.rotation.y = -angle + Math.PI / 2;
          rootMesh.rotation.z = Math.PI / 2.0 + (Math.random() - 0.5) * 0.15;
          rootMesh.rotation.x = (Math.random() - 0.5) * 0.1;
          treeGroup.add(rootMesh);
        }

        const branchLength = 18.0;
        const branchRadiusBottom = 2.2;
        const branchRadiusTop = 1.1;
        const branchGroup = new THREE.Group();
        const branchGeometry = new THREE.CylinderGeometry(
          branchRadiusTop,
          branchRadiusBottom,
          branchLength,
          isMobile ? 8 : 12, // Reduced for mobile
          3
        );
        const branchMesh = new THREE.Mesh(branchGeometry, trunkMaterial);
        branchMesh.castShadow = true;
        branchMesh.receiveShadow = true;
        branchMesh.position.y = branchLength / 2;
        branchGroup.add(branchMesh);
        branchGroup.position.set(
          previousSegmentTopRadius * 0.35,
          overallTrunkHeight * 0.55,
          0
        );
        branchGroup.rotation.z = -Math.PI / 6.5;
        branchGroup.rotation.y = Math.PI / 9;
        treeGroup.add(branchGroup);

        function createFoliageClump(size, numLeaves) {
          const clump = new THREE.Group();
          for (let i = 0; i < numLeaves; i++) {
            const leafSize = size * (Math.random() * 0.55 + 0.7);
            const leafGeometry = new THREE.IcosahedronGeometry(
              leafSize,
              Math.floor(Math.random() * 2)
            );
            const leafMesh = new THREE.Mesh(leafGeometry, foliageMaterial);
            leafMesh.castShadow = true;
            leafMesh.position.set(
              (Math.random() - 0.5) * size * 1.8,
              (Math.random() - 0.5) * size * 1.8,
              (Math.random() - 0.5) * size * 1.8
            );
            leafMesh.rotation.set(
              Math.random() * Math.PI,
              Math.random() * Math.PI,
              Math.random() * Math.PI
            );
            clump.add(leafMesh);
          }
          return clump;
        }

        // Optimized foliage counts
        const topFoliage = createFoliageClump(10.0, performanceSettings.foliageCount);
        topFoliage.position.y = overallTrunkHeight + 4.0;
        treeGroup.add(topFoliage);

        const branchTipLocator = new THREE.Object3D();
        branchTipLocator.position.y = branchLength;
        branchGroup.add(branchTipLocator);
        const branchMidLocator = new THREE.Object3D();
        branchMidLocator.position.y = branchLength * 0.55;
        branchGroup.add(branchMidLocator);
        const worldPos = new THREE.Vector3();

        branchTipLocator.getWorldPosition(worldPos);
        const branchFoliage = createFoliageClump(7.0, performanceSettings.branchFoliageCount);
        branchFoliage.position.copy(treeGroup.worldToLocal(worldPos.clone()));
        treeGroup.add(branchFoliage);

        branchMidLocator.getWorldPosition(worldPos);
        const midBranchFoliage = createFoliageClump(5.5, performanceSettings.midBranchFoliageCount);
        midBranchFoliage.position.copy(
          treeGroup.worldToLocal(worldPos.clone())
        );
        midBranchFoliage.position.y += 1.2;
        treeGroup.add(midBranchFoliage);

        branchGroup.remove(branchTipLocator);
        branchGroup.remove(branchMidLocator);
        return treeGroup;
      }

      function createWiseReader() {
        const readerGroup = new THREE.Group();
        const flatShading = true;
        const roughness = 0.85;
        const characterOverallScale = 0.85;

        const robeMaterial = new THREE.MeshStandardMaterial({
          color: 0x3b4a6b,
          roughness: roughness,
          flatShading: flatShading,
        });
        const skinMaterial = new THREE.MeshStandardMaterial({
          color: 0xbca080,
          roughness: roughness,
          flatShading: flatShading,
        });
        const bookCoverMaterial = new THREE.MeshStandardMaterial({
          color: 0x5d4037,
          roughness: roughness,
          flatShading: flatShading,
        });
        const bookPageMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f5dc,
          roughness: roughness,
          flatShading: flatShading,
        });
        const beardMaterial = new THREE.MeshStandardMaterial({
          color: 0xdcdcdc,
          roughness: roughness,
          flatShading: flatShading,
        });
        const handMaterial = skinMaterial;

        const lowerBodyWidth = 2.0;
        const lowerBodyHeight = 1.5;
        const lowerBodyDepth = 2.2;
        const lowerBodyGeometry = new THREE.BoxGeometry(
          lowerBodyWidth,
          lowerBodyHeight,
          lowerBodyDepth
        );
        const lowerBodyMesh = new THREE.Mesh(lowerBodyGeometry, robeMaterial);
        lowerBodyMesh.position.y = lowerBodyHeight / 2;
        lowerBodyMesh.castShadow = true;
        lowerBodyMesh.receiveShadow = true;
        readerGroup.add(lowerBodyMesh);

        const torsoHeight = 2.3;
        const torsoTopRadius = 0.8;
        const torsoBottomRadius = 1.0;
        const torsoGeometry = new THREE.CylinderGeometry(
          torsoTopRadius,
          torsoBottomRadius,
          torsoHeight,
          isMobile ? 8 : 10 // Reduced for mobile
        );
        const torsoMesh = new THREE.Mesh(torsoGeometry, robeMaterial);
        torsoMesh.position.y = lowerBodyHeight + torsoHeight / 2 - 0.2;
        torsoMesh.position.z = -0.3;
        torsoMesh.rotation.x = THREE.MathUtils.degToRad(-10);
        torsoMesh.castShadow = true;
        torsoMesh.receiveShadow = true;
        readerGroup.add(torsoMesh);

        const headRadius = 1.0;
        const headGeometry = new THREE.SphereGeometry(headRadius, isMobile ? 8 : 10, isMobile ? 6 : 8);
        const headMesh = new THREE.Mesh(headGeometry, skinMaterial);
        const torsoTopCenterY =
          torsoMesh.position.y +
          (torsoHeight / 2) * Math.cos(torsoMesh.rotation.x);
        const torsoTopCenterZ =
          torsoMesh.position.z -
          (torsoHeight / 2) * Math.sin(torsoMesh.rotation.x);
        headMesh.position.y =
          torsoTopCenterY + headRadius * 0.6 * Math.cos(torsoMesh.rotation.x);
        headMesh.position.z =
          torsoTopCenterZ -
          headRadius * 0.6 * Math.sin(torsoMesh.rotation.x) -
          headRadius * 0.1;
        headMesh.rotation.x = THREE.MathUtils.degToRad(15);
        headMesh.castShadow = true;
        headMesh.receiveShadow = true;
        readerGroup.add(headMesh);

        const beardHeight = 1.6;
        const beardRadius = 0.7;
        const beardGeometry = new THREE.ConeGeometry(
          beardRadius,
          beardHeight,
          isMobile ? 6 : 8 // Reduced for mobile
        );
        const beardMesh = new THREE.Mesh(beardGeometry, beardMaterial);
        beardMesh.position.set(
          headMesh.position.x,
          headMesh.position.y - headRadius * 0.45,
          headMesh.position.z + headRadius * 0.6
        );
        beardMesh.rotation.x =
          headMesh.rotation.x + THREE.MathUtils.degToRad(15);
        beardMesh.castShadow = true;
        readerGroup.add(beardMesh);

        const handRadius = 0.4;
        const handGeometry = new THREE.SphereGeometry(handRadius, isMobile ? 4 : 6, isMobile ? 3 : 5);

        const leftHandMesh = new THREE.Mesh(handGeometry, handMaterial);
        leftHandMesh.position.set(
          -torsoTopRadius * 0.6,
          lowerBodyHeight + 0.5,
          lowerBodyDepth * 0.3
        );
        leftHandMesh.castShadow = true;
        readerGroup.add(leftHandMesh);

        const rightHandMesh = new THREE.Mesh(handGeometry, handMaterial);
        rightHandMesh.position.set(
          torsoTopRadius * 0.6,
          lowerBodyHeight + 0.5,
          lowerBodyDepth * 0.3
        );
        rightHandMesh.castShadow = true;
        readerGroup.add(rightHandMesh);

        const bookWidth = 1.8;
        const bookThickness = 0.3;
        const bookDepthDim = 1.4;
        const bookGroup = new THREE.Group();
        const bookCoverGeometry = new THREE.BoxGeometry(
          bookWidth,
          bookThickness,
          bookDepthDim
        );
        const bookCoverMesh = new THREE.Mesh(
          bookCoverGeometry,
          bookCoverMaterial
        );
        bookCoverMesh.castShadow = true;
        bookCoverMesh.receiveShadow = true;
        bookGroup.add(bookCoverMesh);
        const pageThickness = bookThickness * 0.8;
        const pageWidth = bookWidth * 0.95;
        const pageDepthDim = bookDepthDim * 0.95;
        const pageGeometry = new THREE.BoxGeometry(
          pageWidth,
          pageThickness,
          pageDepthDim
        );
        const pageMesh = new THREE.Mesh(pageGeometry, bookPageMaterial);
        pageMesh.position.y = bookThickness * 0.05;
        bookGroup.add(pageMesh);
        bookGroup.position.set(0, lowerBodyHeight + 0.6, lowerBodyDepth * 0.25);
        bookGroup.rotation.x = THREE.MathUtils.degToRad(-45);
        bookGroup.rotation.y = THREE.MathUtils.degToRad(5);
        readerGroup.add(bookGroup);

        readerGroup.scale.set(
          characterOverallScale,
          characterOverallScale,
          characterOverallScale
        );
        return readerGroup;
      }

      // --- Link Orb Creation (Golden Philosopher Orbs) ---
      function createLinkOrb(url, name, originalColorUnused, size = 2.0) {
        const orbGroup = new THREE.Group();
        orbGroup.userData.originalScale = new THREE.Vector3(1, 1, 1); 
        orbGroup.userData.baseEmissiveIntensity = 1.7 + Math.random() * 0.8; // Brighter base for golden shimmer

        const orbColor = new THREE.Color(0xFFD700); // Regal Gold

        const orbGeometry = new THREE.SphereGeometry(size, isMobile ? 16 : 24, isMobile ? 12 : 18); 
        const orbMaterial = new THREE.MeshStandardMaterial({
          color: orbColor,
          emissive: orbColor, 
          emissiveIntensity: orbGroup.userData.baseEmissiveIntensity, 
          roughness: 0.1,     // Shinier for regal gold
          metalness: 0.8,     // More metallic for regal gold
          flatShading: false,
        });
        const orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);
        orbMesh.castShadow = true;

        orbMesh.userData.isLinkOrb = true;
        orbMesh.userData.url = url;
        orbMesh.userData.name = name;
        orbGroup.add(orbMesh);

        const pointLight = new THREE.PointLight(0xFFE580, isMobile ? 2.0 : 2.8, 18 + size * 2.5); // Warmer golden light, dimmer on mobile
        pointLight.position.set(0, 0, 0);
        orbMesh.add(pointLight);

        linkOrbs.push(orbMesh); 
        linkOrbGroups.push(orbGroup); 
        return orbGroup;
      }

      function createLinkOrbs() {
        const treeBaseYOnIsland = tree.position.y;
        const foliageTopRelativeToTreeBase = foliageClumpTopY;
        const absoluteFoliageTopY =
          treeBaseYOnIsland + foliageTopRelativeToTreeBase;

        const orbBaseHeight = absoluteFoliageTopY + 12; 

        // Philosopher data linking to the thinkers directory
        const linkData = [
          { name: "Socrates", url: "./thinkers/socrates.html", color: 0xffd700, size: 2.5, },
          { name: "Plato", url: "./thinkers/plato.html", color: 0xffb800, size: 2.4, },
          { name: "Aristotle", url: "./thinkers/aristotle.html", color: 0xffa500, size: 2.6, },
          { name: "Kant", url: "./thinkers/kant.html", color: 0xffc840, size: 2.3, },
          { name: "Nietzsche", url: "./thinkers/nietzsche.html", color: 0xffe066, size: 2.55, },
          { name: "Hegel", url: "./thinkers/hegel.html", color: 0xff8c00, size: 2.35, },
          { name: "Kierkegaard", url: "./thinkers/kierkegaard.html", color: 0xffdab9, size: 2.25, },
          { name: "Schopenhauer", url: "./thinkers/schopenhaur.html", color: 0xdaa520, size: 2.5, },
          { name: "Heidegger", url: "./thinkers/heidegger.html", color: 0xbdb76b, size: 2.1, },
          { name: "Jung", url: "./thinkers/jung.html", color: 0xffa07a, size: 2.6, },
          { name: "Pessoa", url: "./thinkers/pessoa.html", color: 0xadd8e6, size: 2.2, },
        ];

        linkData.forEach((data, index) => {
          const orb = createLinkOrb(data.url, data.name, data.color, data.size);
          const angle = (index / linkData.length) * Math.PI * 2 + (Math.random() - 0.5) * 0.7; 
          const distanceFromTrunk = baseTrunkRadius + 10 + Math.random() * 15; 
          const orbX = Math.cos(angle) * distanceFromTrunk;
          const orbZ = Math.sin(angle) * distanceFromTrunk;
          const orbY = orbBaseHeight + (Math.random() - 0.5) * 12; 
          orb.position.set( tree.position.x + orbX, orbY, tree.position.z + orbZ );
          island.add(orb);
        });
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(linkOrbs, false); 
        if (intersects.length > 0) {
          const firstIntersectedObject = intersects[0].object;
          if (
            firstIntersectedObject.userData.isLinkOrb &&
            firstIntersectedObject.userData.url
          ) {
            window.open(firstIntersectedObject.userData.url, "_blank");
            showMessage(
              `Exploring: ${firstIntersectedObject.userData.name}`,
              2000
            );
          }
        }
      }

      function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(linkOrbs, false); 

        if (intersects.length > 0) {
          const intersectedMesh = intersects[0].object;
          if (intersectedMesh.userData.isLinkOrb) {
            const targetOrbGroup = intersectedMesh.parent; 
            if (currentHoveredOrbGroup !== targetOrbGroup) {
              if (
                currentHoveredOrbGroup &&
                currentHoveredOrbGroup.userData.originalScale
              ) {
                currentHoveredOrbGroup.scale.copy(
                  currentHoveredOrbGroup.userData.originalScale
                );
              }
              currentHoveredOrbGroup = targetOrbGroup;
              if (currentHoveredOrbGroup.userData.originalScale) {
                currentHoveredOrbGroup.scale
                  .copy(currentHoveredOrbGroup.userData.originalScale)
                  .multiplyScalar(hoverScaleFactor);
              }
              document.body.style.cursor = "pointer";
            }
          } else {
            if (
              currentHoveredOrbGroup &&
              currentHoveredOrbGroup.userData.originalScale
            ) {
              currentHoveredOrbGroup.scale.copy(
                currentHoveredOrbGroup.userData.originalScale
              );
              currentHoveredOrbGroup = null;
              document.body.style.cursor = "default";
            }
          }
        } else {
          if (
            currentHoveredOrbGroup &&
            currentHoveredOrbGroup.userData.originalScale
          ) {
            currentHoveredOrbGroup.scale.copy(
              currentHoveredOrbGroup.userData.originalScale
            );
            currentHoveredOrbGroup = null;
            document.body.style.cursor = "default";
          }
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const elapsedTime = clock.getElapsedTime(); 

        if (skyBackground && skyBackground.material.uniforms.iTime) {
          skyBackground.material.uniforms.iTime.value = elapsedTime * 0.4; 
        }

        linkOrbGroups.forEach((orbGroup, index) => {
            const bobbleFactor = (orbGroup.id || index) * 0.1 + 0.7; 
            orbGroup.position.y +=
              Math.sin(
                elapsedTime * (0.85 + bobbleFactor * 0.85) + (orbGroup.id || index) * 0.5 
              ) * 0.0045; 
            orbGroup.rotation.y +=
              delta *
              (0.028 + 
                Math.sin(elapsedTime * 0.18 + (orbGroup.id || index) * 0.3) * 0.028); 
        });
        
        linkOrbs.forEach((orbMesh, index) => {
            if (orbMesh.material && orbMesh.parent.userData.baseEmissiveIntensity) {
                const shimmerSpeed = 1.4 + (orbMesh.id || index) * 0.1; // Adjusted shimmer for gold
                const shimmerAmount = 0.5; // More pronounced shimmer for gold
                orbMesh.material.emissiveIntensity = 
                    orbMesh.parent.userData.baseEmissiveIntensity + 
                    Math.sin(elapsedTime * shimmerSpeed + (orbMesh.id || index) * 0.7) * shimmerAmount;
            }
        });


        controls.update();
        renderer.render(scene, camera);
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    </script>
  </body>
</html>
